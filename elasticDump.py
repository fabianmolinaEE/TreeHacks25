from elasticsearch import Elasticsearch
from sentence_transformers import SentenceTransformer

# Initialize Elasticsearch client

es = Elasticsearch(
    "https://myhidden",
    api_key="hidden",
    timeout=20,  # Increase timeout to 30 seconds
    max_retries=3,
    retry_on_timeout=True
)
# Initialize sentence transformer model
model = SentenceTransformer('all-MiniLM-L6-v2')

def process_and_index_content(data, Uprompt):
    link = data['link']
    content_type = data['type']
    query = Uprompt
    content = data['content']

    # Generate vector embedding
    content_vector = model.encode(content).tolist()
    prompt_vector = model.encode(query).tolist()

    # Prepare document for indexing
    doc = {
        'link': link,
        'type': content_type,
        'prompt': Uprompt,
        'prompt_vector': prompt_vector,
        'content': content,
        'content_vector': content_vector
         
    }

    # Index the document
    es.index(index="course_resources", body=doc)
    print(f"Indexed document: {link}")

# Example usage
scraped_data ={
    "link": "https://web.stanford.edu/class/archive/cs/cs111/cs111.1254/lectures/5/Lecture5.pdf",
    "type": "pdf",
    "content": "1\nThis document is copyright (C) Stanford Computer Science and Nick Troccoli, licensed under \nCreative Commons Attribution 2.5 License.  All rights reserved.\nBased on slides and notes created by John Ousterhout, Jerry Cain, Chris Gregg, and others. \nNOTICE RE UPLOADING TO WEBSITES:  This content is protected and may not be shared, \nuploaded, or distributed. (without expressed written permission)\nCS111, Lecture 5\nCrash Recovery\nOptional reading:\nOperating Systems: Principles and Practice (2nd Edition): Chapter 14 \nthrough 14.1\n\n2\nCS111 Topic 1: Filesystems\nFilesystems \nintroduction and \ndesign\nCase study: Unix \nV6 Filesystem\nCrash Recovery\nFilesystem \nSystem calls and \nfile descriptors\nLecture 2\nLecture 3-4\nToday/Lecture 6\nLecture 6-7\nKey Question: How can we design filesystems to manage files on disk, and what are \nthe tradeoffs inherent in designing them?  How can we interact with the filesystem in \nour programs?\nassign2: implement a program that can repair a filesystem after a crash, and explore \nsome of the security and ethical implications of OSes / filesystems.\n\n3\nOther Filesystem Design Ideas\nLarger block size?  Improves efficiency of I/O and inodes but worsens internal \nfragmentation.  Generally: challenges with both large and small files coexisting.\nOne idea: multiple block sizes\n\u2022 Large blocks are 4KB, fragments are 512 bytes (8 fragments fit in a block)\n\u2022 The last block in a file can be 0-7 fragments\n\u2022  One large block can hold fragments from multiple files\n\u2022 Get the time efficiency benefit of larger blocks, but the internal fragmentation \nbenefit of smaller blocks (small files can use fragments)\n\n4\nFilesystem Techniques Today\n\u2022 Filesystem design is a hard problem!  Tradeoffs, challenges with large and small \nfiles.\n\u2022 Even larger block sizes (16KB large blocks, 2KB fragments) \u2013 disk space cheap, \ninternal fragmentation doesn\u2019t matter as much\n\u2022 Reallocate files as blocks grow \u2013 initially allocate blocks one at a time, but \nwhen a file reaches a certain size, reallocate blocks looking for large contiguous \nclusters\n\u2022 ext4 is a popular current Linux filesystem \u2013 you may notice similarities!\n\u2022 NTFS (replacement for FAT) is the current Windows filesystem\n\u2022 APFS (\u201cApple Filesystem\u201d) is the filesystem for Apple devices\n\n5\nAdditional Filesystem Info\nQ: Why do spinning disks only support reading/writing in units of sectors?\nA: one reason is the disk does error-correction per-sector on disk, so imposes \nrestriction on reading/writing whole sectors\n\n6\nLearning Goals\n\u2022 Learn about the role of the free map and block cache in filesystems\n\u2022 Understand the goals of crash recovery and potential tradeoffs\n\u2022 Compare and contrast different approaches to crash recovery\n\n7\nPlan For Today\n\u2022 Free space management\n\u2022 Block Cache\n\u2022 Crash Recovery Overview\n\u2022 Approach #1: Consistency check on reboot (fsck)\n\u2022 Approach #2: Ordered Writes\n\n8\nCrash Recovery\nTo understand crash recovery, we need to understand all places where \nfilesystem data is stored and maintained.\n\u2022 We know about most of the disk itself (e.g. Unix V6 layout)\n\u2022 We\u2019ll learn about how free blocks on disk are tracked.  This factors into crash \nrecovery (e.g. free blocks not in a consistent state).\n\u2022 We\u2019ll learn about the block cache in memory that stores frequently-used \nblocks accessed from disk.\n\n9\nPlan For Today\n\u2022 Free space management\n\u2022 Block Cache\n\u2022 Crash Recovery Overview\n\u2022 Approach #1: Consistency check on reboot (fsck)\n\u2022 Approach #2: Ordered Writes\n\n10\nFree Space Management\nEarly Unix systems (like Unix v6) used a linked list of free blocks \n\u2022 Initially sorted, so files allocated contiguously, but over time list becomes \nscrambled\nMore common: use a bitmap\n\u2022 Array of bits, one per block: 1 means block is free, 0 means in use\n\u2022 Takes up some space \u2013 e.g. 1TB capacity -> 228 4KB blocks -> 32 MB bitmap\n\u2022 During allocation, search bit map for block close to previous block in file\n\u2022 Want locality \u2013 data likely used next is close by (linked list not as good)\nProblem: slow if disk is nearly full, and files become very scattered\n\n11\nFree Space Management\nMore common: use a bitmap \u2013 an array of bits, one per block, where 1 means \nblock is free, 0 means in use.\n\u2022 During allocation, search bit map for block close to previous block in file\nProblem: slow if disk is nearly full, and blocks very scattered\n\u2022 Expensive operation to find a free block on a mostly full disk\n\u2022 Poor locality \u2013 data likely to be used next is not close by\nSolution (used by BSD): don\u2019t let disk fill up!\n\u2022 E.g. Linux pretends disk has less capacity than it really has (try df on myth!)\n\u2022 Increase disk cost, but for better performance\n\n12\nPlan For Today\n\u2022 Free space management\n\u2022 Block Cache\n\u2022 Crash Recovery Overview\n\u2022 Approach #1: Consistency check on reboot (fsck)\n\u2022 Approach #2: Ordered Writes\n\n13\nBlock Cache\nProblem: Accessing disk blocks is expensive, especially if we do it repeatedly for \nthe same blocks.\nIdea: use part of main memory to retain recently-accessed disk blocks. (Many \nOSes do this).\n\u2022 A cache is a space to store and quickly access recently- / frequently-used data.\n\u2022 Frequently-referenced blocks (e.g. indirect blocks for large files) usually in \nblock cache. (not necessarily whole files, just individual blocks).\n\u2022 Invisible to programs \u2013 but all operations go through the block cache\n\u2022 Challenge: how do we utilize it?  What if it gets full?\n\n14\nBlock Cache\nChallenge: how do we utilize it?  What if it gets full?\nOne approach - least-recently-used \u201cLRU\u201d replacement \u2013 If we need something \nnot in the cache, we read it from disk and then add it to the cache.  If there\u2019s no \nroom in the cache, we remove the least-recently-used element. \n\n15\nBlock Cache\nKey Question: When a block in the block cache is modified, do we stop and wait \nand immediately write it to disk?  Or do we delay it slightly until later?\n\u201cSynchronous Writes\u201d\nWrite immediately to disk\n\u201cDelayed Writes\u201d\nDon\u2019t write immediately to disk\n\u2022\nWait (e.g. Unix used 30sec) in case of more \nwrites to a block, or it is deleted\n\n16\nBlock Cache\nKey Question: When a block in the block cache is modified, do we stop and wait \nand immediately write it to disk?  Or do we delay it slightly until later?\n\u201cSynchronous Writes\u201d\nWrite immediately to disk\n\u201cDelayed Writes\u201d\nDon\u2019t write immediately to disk\n\u2022\nSlow: program must wait to proceed until \ndisk I/O completes\n\u2022\nSafer: less risk (but not zero risk!) of data \nloss because it\u2019s written as soon as possible.\n\u2022\nWait (e.g. Unix used 30sec) in case of more \nwrites to a block, or it is deleted\n\n17\nBlock Cache\nKey Question: When a block in the block cache is modified, do we stop and wait \nand immediately write it to disk?  Or do we delay it slightly until later?\n\u201cSynchronous Writes\u201d\nWrite immediately to disk\n\u201cDelayed Writes\u201d\nDon\u2019t write immediately to disk\n\u2022\nSlow: program must wait to proceed until \ndisk I/O completes\n\u2022\nSafer: less risk (but not zero risk!) of data \nloss because it\u2019s written as soon as possible.\n\u2022\nWait (e.g. Unix used 30sec) in case of more \nwrites to a block, or it is deleted\n\u2022\nFast + Efficient: writes return immediately, \neliminates disk I/Os in many cases (e.g. \nmany small writes to the same block)\n\u2022\nLess safe: may lose more data after a system \ncrash!  \u201cAre you willing to lose your last \n30sec of work in exchange for a \nperformance bump?\u201d (if e.g. ~2-10x faster)\n\u2022\n(Aside\u2013 program can call fsync function to \nforce disk write)\n\n18\nBlock Cache\nThe block cache could also end up reordering operations!\n\u2022 E.g. a bunch of operations performed, written to block cache with delayed \nwrites\n\u2022 After e.g. 30s, we go through and flush blocks to disk, could flush them in \nsome order different from original operation order.\n\n19\nPlan For Today\n\u2022 Free space management\n\u2022 Block Cache\n\u2022 Crash Recovery Overview\n\u2022 Approach #1: Consistency check on reboot (fsck)\n\u2022 Approach #2: Ordered Writes\n\n20\nCrash Recovery\nSometimes, computers crash or shut down unexpectedly.   In those situations, \nwe want to avoid filesystem data loss or corruption as much as possible.\nHow can we recover from crashes without losing file data or corrupting the \ndisk?\nassign2: implement a program that can repair a filesystem after a crash, and explore \nsome of the security and ethical implications of OSes / filesystems.\n\n21\nCrash Recovery\nChallenge #1 \u2013 data loss: crashes can happen at any time, and not all data might \nhave been saved to disk.\n\u2022 E.g. if you saved a file but it hadn\u2019t actually been written to disk yet.\nChallenge #2 - inconsistency: Crashes could happen even in the middle of \noperations, and this could leave the disk in an inconsistent state.\n\u2022 E.g. if a modification affects multiple blocks, a crash could occur when some of \nthe blocks have been written to disk but not the others.\nIdeally, filesystem operations would be atomic, meaning they happen either \nentirely or not at all.  But this isn\u2019t fully possible.\n\n22\nExample Filesystem Operations\nMain steps to create a file with some data in it:\n\u2022 Initialize a new inode\n\u2022 Add directory entry to refer to that inode\n\u2022 Update free list to mark newly-used payload data blocks as used\n\u2022 Write data to new payload blocks\nMain steps to add another block of data to an existing file:\n\u2022 Update free list to mark new block as used\n\u2022 Update inode to store new block number (and other fields like size, etc.)\n\u2022 Write data to new block\nOperations may not be written to disk in these specific orders!\n\n23\nCrash Recovery\nChallenge #2 - inconsistency: Crashes could happen even in the middle of \noperations, and this could leave the disk in an inconsistent state.\nWhat if:\n1. Update free list to mark \nnew block as used\n2. Update inode to store new \nblock number\n3. Write data to new block\nWhat if:\n1. Update inode to store new \nblock number\n2. Write data to new block\n3. Update free list to mark \nnew block as used\nCrash!\nCrash!\nProblem: on reboot, file has \ngarbage block!\nProblem: our block could be \ngiven out later to someone else!\n\n24\nCrash Recovery\nKey challenge: tradeoffs between \ncrash recovery abilities and filesystem \nperformance.\n\n25\nCrash Recovery\nWe will discuss 3 approaches to crash recovery, building up to the most common \none \u2013 logging:\n1. Consistency Check on reboot (fsck)\n2. Ordered Writes\n3. Write-Ahead Logging (\u201cJournaling\u201d)\n\n26\nPlan For Today\n\u2022 Free space management\n\u2022 Block Cache\n\u2022 Crash Recovery Overview\n\u2022 Approach #1: Consistency check on reboot (fsck)\n\u2022 Approach #2: Ordered Writes\n\n27\nfsck\nIdea #1: write a program that runs on bootup to check the filesystem for \nconsistency and repair any problems it can.\nExample: Unix fsck (\u201cfile system check\u201d)\n\u2022 Must check whether there was a clean shutdown (if so, no work to do).  How \ndo we know?  Set flag on disk on clean shutdown, clear flag on reboot.\n\u2022 If there wasn\u2019t, then scan disk contents, identify inconsistencies, repair them.\n\u2022 Scans metadata (inodes, indirect blocks, free list, directories)\n\u2022 Goals: restore consistency, minimize info loss\n\n28\nPossible fsck Scenarios\nExample #1: block in file and also in free list?\nAction: remove block from free list\nWhat if:\n1. Update inode to store new \nblock number\n2. Write data to new block\n3. Update free list to mark \nnew block as used\nCrash!\n\n29\nPossible fsck Scenarios\nExample 2: block a part of two different files (how is this possible??)\nLet\u2019s say we are deleting file A and also creating file B, which coincidentally uses \nthe same old payload blocks that A used.\nKey Idea: after all these operations, their changes are in the block cache. But the \ncache could write the blocks to disk in some order, and we could crash before all \nblocks are written!\nTo delete file A, we need to\u2026\nTo create file B, we need to\u2026\n\u2022 Delete inode A\n\u2022 Mark A\u2019s payload blocks as free in \nfree list\n\u2022 Create inode B\n\u2022 Add dirent for B\n\u2022 Mark same payload blocks as used \nin free list\n\u2022 Write data to new blocks\n\n30\nPossible fsck Scenarios\nExample 2: block a part of two different files (how is this possible??)\nLet\u2019s say we are deleting file A and also creating file B, which coincidentally uses \nthe same old payload blocks that A used.\nTo delete file A, we \nneed to\u2026\nTo create file B, we \nneed to\u2026\n\u2022\nDelete inode A\n\u2022\nMark A\u2019s payload \nblocks as free in \nfree list\n\u2022\nCreate inode B\n\u2022\nAdd dirent for B\n\u2022\nMark same payload \nblocks as used in \nfree list\n\u2022\nWrite data to new \nblocks\nWhat if: all operations performed in \nblock cache, then block cache writes \ninode B\u2019s block to disk.\nTHEN CRASH!\nNo other blocks written to disk \uf04c \n\n31\nPossible fsck Scenarios\nExample 2: block a part of two different files (how is this possible??)\nAction: Make a copy for each? (works, though potential security issues if block is \nmigrated to unintended file)  Remove from both? (probably not, don\u2019t want to \nlose potentially-useful data)\nExample 3: inode reference count (# times referenced by a directory entry) = 1, \nbut not referenced in any directory.\nAction: create link in special lost+found directory.\n\n32\nLimitations of fsck\nWhat are the downsides/limitations of fsck?\n\u2022 Time: can\u2019t restart system until fsck completes.  Larger disks mean larger \nrecovery time (Used to be manageable, but now to read every block \nsequentially in a 5TB disk -> 8 hours!)\n\u2022 Restores consistency but doesn\u2019t prevent loss of information.\n\u2022 Restores consistency but filesystem may still be unusable (e.g. a bunch of core \nsystem files moved to lost+found)\n\u2022 Security issues: a block could migrate from a password file to some other \nrandom file.\nCan we do better?  Can we avoid having to scan the whole disk on reboot?\n\n33\nPlan For Today\n\u2022 Free space management\n\u2022 Block Cache\n\u2022 Crash Recovery Overview\n\u2022 Approach #1: Consistency check on reboot (fsck)\n\u2022 Approach #2: Ordered Writes\n\n34\nOrdered Writes\nCorruption Example: block in file and also in free list. (e.g. file growing, claims \nblock from free list, but crash before free list updates)\nKey insight: we are performing 2 operations \u2013 removing block from free list, plus \nadding block number to inode.  If we want to ensure that a block is never both in \nthe free list and in an inode simultaneously, which operation should we do first?  \nWould this resolve all problems?\nRespond on PollEv: \npollev.com/cs111\n\n35\n\n36\nOrdered Writes\nIdea #2: We could prevent certain kinds of inconsistencies by making updates in \na particular order. \nExample: adding block to file: first write back the free list, then write the inode.  \nThus, we could never have a block in both the free list and an inode.  However, \nwe could leak disk blocks (how?)\n\n41\nRecap\n\u2022 Free space management\n\u2022 Block Cache\n\u2022 Crash Recovery Overview\n\u2022 Approach #1: Consistency check on \nreboot (fsck)\n\u2022 Approach #2: Ordered Writes\nNext time: more about crash recovery\nLecture 5 takeaways: The \nfree list tracks free blocks on \ndisk and is commonly \nimplemented using a bitmap.  \nThe block cache caches \nrecently-accessed disk \nblocks.  Crash recovery \nchallenges include both data \nloss and inconsistency.  Fsck \nand ordered writes are 2 \napproaches to crash recovery.\n"
}


process_and_index_content(scraped_data, "I am in a course CS111 at Stanford. I am confused on lecture 10")
